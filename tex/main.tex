\documentclass[12pt,a4paper,parskip=full]{scrartcl}
\KOMAoption{bibliography}{totoc}
\KOMAoption{listof}{totoc}

%display boundaries
%\usepackage{showframe}

\usepackage{cite}
\usepackage[pdftex]{graphicx}
\graphicspath{{graphics/}}

\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{tocloft}
\usepackage{subcaption}

\usepackage{url}

\usepackage{makeidx}
\usepackage[colorlinks,hyperindex,plainpages=false,
pdftitle={High-frequency characterization of a Software Defined Radio (SDR) platform},
pdfauthor={Gernot Vormayr},
pdfsubject={Bachelor thesis},
pdfkeywords={Hochfrequenz,Software Defined Radio,SDR,GNU Radio,USRP},
pdfpagelabels,
pagebackref,
bookmarksopen=false
]{hyperref}

\usepackage[binary-units]{siunitx}
\usepackage{pgfplots}

\pgfplotsset{compat=1.11}
\pgfplotsset{every axis plot/.append style={smooth}} 

\usepgfplotslibrary{units}
\pgfplotsset{unit code/.code 2 args={\si{#1#2}}}

\usepackage{tikz}
\usetikzlibrary{dsp,chains,fit,matrix}

\makeatletter
\pgfdeclareshape{dspswitchshape}{%
    \inheritsavedanchors[from=rectangle]
    \inheritanchorborder[from=rectangle]
    \inheritanchor[from=rectangle]{north}
    \inheritanchor[from=rectangle]{north west}
    \inheritanchor[from=rectangle]{north east}
    \inheritanchor[from=rectangle]{center}
    \inheritanchor[from=rectangle]{west}
    \inheritanchor[from=rectangle]{east}
    \inheritanchor[from=rectangle]{mid}
    \inheritanchor[from=rectangle]{mid west}
    \inheritanchor[from=rectangle]{mid east}
    \inheritanchor[from=rectangle]{base}
    \inheritanchor[from=rectangle]{base west}
    \inheritanchor[from=rectangle]{base east}
    \inheritanchor[from=rectangle]{south}
    \inheritanchor[from=rectangle]{south west}
    \inheritanchor[from=rectangle]{south east}
    \backgroundpath{%
      \pgfpathrectanglecorners
      {\pgfpointadd{\southwest}{\pgfpoint{\pgfkeysvalueof{/pgf/outer xsep}}{\pgfkeysvalueof{/pgf/outer ysep}}}}
      {\pgfpointadd{\northeast}{\pgfpointscale{-1}{\pgfpoint{\pgfkeysvalueof{/pgf/outer xsep}}{\pgfkeysvalueof{/pgf/outer ysep}}}}}
      \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
      \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
      \advance\pgf@xa by 6pt
      \advance\pgf@xb by -6pt
      \advance\pgf@yb by -7pt
      \advance\pgf@ya by 7pt
      {%
          \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
          \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
          \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
          \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
          \pgfusepath{stroke}
          \pgfpathmoveto{\pgfpoint{\pgf@xb}{\pgf@yb}}
          \pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@ya}}
          \pgfpathmoveto{\pgfpoint{\pgf@xb}{\pgf@ya}}
          \pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@yb}}
          \pgfsetdash{{0.5pt}{1pt}}{0pt}
          \pgfusepath{stroke}
      }
      {\pgfpathcircle{\pgfpoint{\pgf@xa}{\pgf@yb}}{2pt}}
      {\pgfpathcircle{\pgfpoint{\pgf@xb}{\pgf@yb}}{2pt}}
      {\pgfpathcircle{\pgfpoint{\pgf@xa}{\pgf@ya}}{2pt}}
      {\pgfpathcircle{\pgfpoint{\pgf@xb}{\pgf@ya}}{2pt}}
      \pgfsetdash{}{0pt}
      \color{white}
      \pgfsetstrokecolor{black} 
      \pgfusepath{fill,stroke}
    }
}
\tikzset{dspswitch/.style={shape=dspswitchshape,draw,align=center,text depth=0.3em,text height=1em,inner sep=0pt,
         line cap=round,line join=round,line width=\dsplinewidth,minimum size=\dspsquareblocksize}}
\makeatother

\usepgfplotslibrary{external}
\tikzexternalize
\tikzsetexternalprefix{figures/}

\DeclareSIUnit \belm {Bm}
\DeclareSIUnit \belfs {BFS}
\DeclareSIUnit \samples {S}
\sisetup{per-mode = symbol}

\lstset{language=Python,numbers=left,numberstyle=\tiny,stepnumber=5,numbersep=5pt,frame=single,
breaklines=true,postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
captionpos=b,escapeinside={(*}{*)}}

\usepackage{cleveref}

\begin{document}
\begin{titlepage}
    \enlargethispage{1cm}
    \centering
    \begin{minipage}{0.49\linewidth}
        \includegraphics[height=1.5cm,keepaspectratio]{EMCE_Logo_CMYK_color}
    \end{minipage}
    \begin{minipage}{0.49\linewidth}
        \flushright
        \includegraphics[height=1.5cm,keepaspectratio]{TULogo_CMYK}
    \end{minipage}\\
    \vspace*{5cm}
    {\Huge \textbf{Bachelor thesis}}\\
    \vspace*{1cm}
    {\Large High-frequency characterization of a Software Defined Radio (SDR) platform}

    \vspace*{2cm}
    {\large Gernot ~\textsc{Vormayr} ~\\ 0425210 } ~\\ 

    \vfill
    {Supervisor} ~\\\vspace*{0.1cm}
    {Ass.Prof. Dipl.-Ing. Dr.techn. \large Holger ~\textsc{Arthaber}} ~\\
    {Univ.Ass. Dipl.-Ing. Dr.techn. \large Thomas ~\textsc{Faseth}}
    \vspace*{2cm}

    \rule{\linewidth}{0.4pt}
    \begin{minipage}[t]{0.7\linewidth}
        \begin{large}
            EMCE - Institute of Electrodynamics, Microwave and Circuit Engineering
        \end{large}\\
        Vienna University of Technology
    \end{minipage}
    \begin{minipage}[t]{0.27\linewidth}
        Gusshausstrasse 25\\
        1040 Vienna\\
        www.emce.tuwien.ac.at
    \end{minipage}
    \vspace*{-3pt}
    \rule{\linewidth}{0.4pt}
    \clearpage
\end{titlepage}

\tableofcontents

\begin{abstract}
    The low cost Ettus Research USRP\footnote{Univeral Software Radio Platform} 
    combined with GNURadio enables implementing cheap and simple radio solutions.
    This allows rapid prototyping of new radio protocols, easier test setups for
    lab purposes and even reconstructing old analog communications hardware on a
    budget. Although Ettus Research provides schematics, source code, and documentation,
    there is no data available on the RF characteristics of the USRP devices.
\end{abstract}

\section{Introduction}
Software defined radio systems (SDR) can be operated on a very broad frequency range,
can be easily adapted to various needs and allow operations which would be
impossible or very expensive in analog hardware. A SDR consists of specialised
software, a general purpose computer, and an analog front end with fast
ADCs/DACs and optionally DSP and mixing capabilities. One of those front ends is
the Ettus Research USRP N2x0 product family. This family consists of the N200 and
the N210, which has a bigger FPGA, allowing additional custom DSP code directly
in the device. Both contain \SI{100}{\mega\samples\per\second} dual ADC,
\SI{400}{\mega\samples\per\second} dual DAC, Xilinx Spartan
3A-DSP, and Gigabit Ethernet connectivity to stream data. The analog part needs
to be provided by one of several possible daughter boards, which allow operation
from DC to 6 GHz\cite{ettus_n2x0}. This products are also available as rebranded
versions from NI.
\subsection{NI USRP-2922}
The NI USRP-2922 is a rebranded Ettus Research N210 with an SBX daughter board, which
allows frequency ranges from \SI{400}{\mega\hertz} to \SI{4.4}{\giga\hertz}. Both RX
and TX feature amplifiers and an attenuator to allow specifying an overall gain from
\SI{0}{\deci\bel} to \SI{31.5}{\deci\bel} in \SI{0.5}{\deci\bel} steps. Furthermore
both feature a clock synthesizer to generate the desired frequency from the \SI{100}{\mega\hertz}
base clock of the FPGA board, mixers and appropriate filtering. Digital to analog and analog to
digital conversion is handled by the FPGA board at a fixed sampling rate of
\SI{100}{\mega\samples\per\second}. Samples can be transferred to and from the device via the
GBit network interface. This limits the maximum sampling rate for \SI{16}{\bit} to
\SI{25}{\mega\samples\per\second} and \SI{50}{\mega\samples\per\second} for \SI{8}{\bit}.
A detailed overview can be seen in \cref{fig:usrp}. Galler's master's thesis \cite{flo}
give a more in depth description of the analog front end and the FPGA board.
\begin{figure}[htb]
    \begin{subfigure}{0.5\linewidth}
        \centering
        \includegraphics[scale=0.5]{overall}
    \end{subfigure}
    \begin{subfigure}{0.5\linewidth}
        \centering
        \includegraphics[scale=0.5]{sbx}
    \end{subfigure}
    \caption{Overview of the hardware on the N210 circuit board and SBX ciruit board\cite{flo}.}
    \label{fig:usrp}
\end{figure}
Since this overview was created according
to the schematics in \cite{sch_sbx}, the filters LP2 and LP5 state wrong cutoff frequencies.
Those seem to differ between the Ettus Research SBX and the NI USRP-2922, where both have an
actual cutoff frequency of \SI{20}{\mega\hertz}. This is mentioned in the marketing material
\cite{ni_29xx} only and can also be seen in \cref{sec:rftx}. %TODO also rfrx?


It is advisable to always use the latest driver versions, which are not necessarily included in
the recent Linux distributions. Changes to byte ordering in the protocol \cite{usrp_byte} can
generate frequency artifacts in \SI{8}{\bit} mode and a bug in the configuration of the half
band filters can lead to two tones at \SI{50}{\mega\samples\per\second} \cite{usrp_hb}.


Digital down conversion for RX and digital up conversion for TX are handled by two dedicated DSP chains.
\Cref{sec:dsprx} and \cref{sec:dsptx} explain both in more detail, which has been derived from the FPGA sources at \cite{usrp_src}.
In order to minimize noise, both chains use round to nearest with error diffusion and clipping
for converting signals to lower bit withs. IQ samples are generated with a final bit width of
\SI{16}{\bit} per channel. If the \SI{8}{\bit} line format is used, then the lower \SI{8}{\bit}
are truncated from the sample.
\subsubsection{DSP RX chain}
\label{sec:dsprx}
\begin{figure}[htb]
    \centering
\resizebox{\linewidth}{!}{
\begin{tikzpicture}
    \matrix (m1) [row sep=5mm, column sep=5mm,ampersand replacement=\&]
    {
        \&
        \node[coordinate]                           (ma0) {};       \&
        \node[coordinate]                           (ma1) {};       \&
        \node[coordinate]                           (ma2) {};       \&
        \node[coordinate]                           (ma3) {};       \&
        \node[coordinate]                           (ma4) {};       \&
        \node[coordinate]                           (ma5) {};       \&
        \node                                       (ma6) {mag};    \\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (m00) {};       \&
        \node[coordinate]                           (m01) {};       \&
        \node[coordinate]                           (m02) {};       \&
        \node[dspsquare]                            (m03) {$\sum$}; \&
        \node[coordinate]                           (m04) {};       \&
        \node[coordinate]                           (m05) {};       \&
        \node[dspmixer]                             (m06) {};       \&
        \node[coordinate]                           (m07) {};       \&
        \node[coordinate]                           (m08) {};       \&
        \node                                       (m09) {phase};  \\
        %------------------------------------------------------------
        \&
        \node[dspnodeopen,dsp/label=above]          (m10) {adc\_a}; \&
        \node[coordinate]                           (m11) {};       \&
        \node[coordinate]                           (m12) {};       \&
        \node[dspadder,label=100:{-}]               (m13) {};      \&
        \node[dspnodefull]                          (m14) {};       \&
        \node[dspnodefull]                          (m15) {};       \&
        \node[dspadder]                             (m16) {};       \&
        \node[coordinate]                           (m17) {};       \&
        \node[coordinate]                           (m18) {};       \&
        \node[dspsquare]                            (m19) {$\sum$}; \&
        \node[coordinate]                           (m110){};       \&
        \node[dspsquare]                            (m111){CIC};    \&
        \node[dspsquare,label=above:small]          (m112){hb};     \&
        \node[dspsquare]                            (m113){hb};     \&
        \node[dspmixer]                             (m114){};       \&
        \node[coordinate]                           (m115){};       \\

        %------------------------------------------------------------
        \&
        \node[coordinate]                           (m20) {};       \&
        \node[coordinate]                           (m21) {};       \&
        \node[dspswitch]                            (m22) {};       \&
        \node[coordinate]                           (m23) {};       \&
        \node[coordinate]                           (m24) {};       \&
        \node[coordinate]                           (m25) {};       \&
        \node[coordinate]                           (m26) {};       \&
        \node[coordinate]                           (m27) {};       \&
        \node[dspswitch]                            (m28) {};       \&
        \node[dspsquare]                            (m29) {cordic}; \&
        \node[coordinate]                           (m210) {};   \&
        \node[coordinate]                           (m211) {};      \&
        \node[coordinate]                           (m212) {};      \&
        \node[coordinate]                           (m213) {};      \&
        \node                                       (m214) {scale}; \&
        \node[coordinate]                           (m215) {};      \&
        \&
        \node[dspnodeopen,dsp/label=above]          (m216) {sample}; \&
        \\
        %------------------------------------------------------------
        \&
        \node[dspnodeopen,dsp/label=below]          (m30) {adc\_b}; \&
        \node[coordinate]                           (m31) {};       \&
        \node[coordinate]                           (m32) {};       \&
        \node[dspadder,label=-100:{-}]              (m33) {};       \&
        \node[dspnodefull]                          (m34) {};       \&
        \node[coordinate]                           (m35) {};       \&
        \node[dspadder]                             (m36) {};       \&
        \node[coordinate]                           (m37) {};       \&
        \node[coordinate]                           (m38) {};       \&
        \node[coordinate]                           (m39) {};       \&
        \node[coordinate]                           (m310){};       \&
        \node[dspsquare]                            (m311){CIC};    \&
        \node[dspsquare,label=below:small]          (m312){hb};     \&
        \node[dspsquare]                            (m313){hb};     \&
        \node[dspmixer]                             (m314){};       \&
        \node[coordinate]                           (m315){};       \\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (m40) {};       \&
        \node[coordinate]                           (m41) {};       \&
        \node[coordinate]                           (m42) {};       \&
        \node[dspsquare]                            (m43) {$\sum$}; \&
        \node[coordinate]                           (m44) {};       \&
        \node[coordinate]                           (m45) {};       \&
        \node[dspmixer]                             (m46) {};       \\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (mb0) {};       \&
        \node[coordinate]                           (mb1) {};       \&
        \node[coordinate]                           (mb2) {};       \&
        \node[coordinate]                           (mb3) {};       \&
        \node[coordinate]                           (mb4) {};       \&
        \node[coordinate]                           (mb5) {};       \&
        \node                                       (mb6) {phase};  \\
    };
    \draw[dspline] (m09) -- (m19);
    \draw[dspconn] (m19) -- (m29);
    %connections start -> dc offset
    \foreach \off/\i in {1mm/1,-1mm/3}
    {
        \draw[dspflow] (m\i0) -- (m\i1);
        \draw[dspline] (m\i1) -- ([yshift=\off]m21) -- ([yshift=\off]m22.west);
        \draw[dspline] ([yshift=\off]m22.east) -- ([yshift=\off]m23);
        \draw[dspconn] ([yshift=\off]m23) -- (m\i3);
    }
    %top connection dc offset -> correction
    \begin{scope}[start chain]
        \chainin (m14);
        \chainin (m04) [join=by dspline];
        \chainin (m03) [join=by dspconn];
        \chainin (m13) [join=by dspconn];
        \chainin (m14) [join=by dspconn];
        \chainin (m15) [join=by dspconn];
        \chainin (m05) [join=by dspline];
        \chainin (m06) [join=by dspconn];
        \chainin (m16) [join=by dspconn];
    \end{scope}
    \draw[dspconn] (m15) -- (m16);
    \draw[dspline] (m16) -- (m17) -- ([yshift=1mm]m27);
    %bottom connection dc offset -> correction
    \begin{scope}[start chain]
        \chainin (m34);
        \chainin (m44) [join=by dspline];
        \chainin (m43) [join=by dspconn];
        \chainin (m33) [join=by dspconn];
        \chainin (m34) [join=by dspconn];
        \chainin (m36) [join=by dspconn];
        \chainin (m37) [join=by dspline];
    \end{scope}
    \draw[dspline] (m37) -- ([yshift=-1mm]m27);
    \draw[dspline] (m15) -- (m45);
    \draw[dspconn] (m45) -- (m46) -- (m36);
    \draw[dspline] (ma6) -- (m06);
    \draw[dspline] (mb6) -- (m46);
    %connection sw -> CIC
    \begin{scope}[dspconn]
        \draw ([yshift=1mm]m28.east) -- node[above] {i} ([yshift=1mm]m29.west);
        \draw ([yshift=-1mm]m28.east) -- node[below] {q} ([yshift=-1mm]m29.west);
    \end{scope}
    

    \foreach \off/\i in {1mm/1,-1mm/3}
    {
        \draw[dspconn] ([yshift=\off]m27) -- ([yshift=\off]m28.west);
        \draw[dspline] ([yshift=\off]m29.east) -- ([yshift=\off]m210) -- (m\i10);
        \begin{scope}[start chain]
            \chainin (m\i10);
            \foreach \j in {11,12,13,14}
            {
                \chainin (m\i\j)[join=by dspconn];
            }
        \end{scope}
        \begin{scope}[start chain]
            \chainin (m214);
            \chainin (m\i14)[join=by dspline];
            \chainin (m\i15)[join=by dspline];
            \chainin (m215)[join=by dspline];
        \end{scope}

    }
    \draw[dspflow] (m215) -- (m216);

    \node[draw,inner xsep=5pt,inner ysep=20pt,dashed,fit=(m03) (m13) (m14),label=above:{DC offset}] {};
    \node[draw,inner xsep=5pt,inner ysep=20pt,dashed,fit=(m43) (m33) (m34),label=below:{DC offset}] {};
    \node[draw,inner xsep=5pt,inner ysep=20pt,dashed,fit=(ma6) (mb6) (m15),label=below:{IQ balance}] {};
\end{tikzpicture}}
    \caption{DSP RX chain}
    \label{fig:rxpath}
\end{figure}
The RX chain (\cref{fig:rxpath}) starts with a multiplexer which allows
interchanging the data from ADC a and ADC b. This is followed by the DC offset correction.
The accumulator can be turned off and be set to a fixed value.
This allows static DC offsets as well as completely turning off the compensation. Data 
generated by this stage has a width of \SI{18}{\bit}. IQ imbalance can be corrected by the
next stage, which is done automatically if a calibration file is present. Calibration can be
performed with the command \verb+uhd_cal_rx_iq_balance+\cite{usrp_cal}. This stage adds additional
\SI{6}{\bit} for a total of \SI{24}{\bit} to the data stream. Before entering the cordic data from
ADC a and ADC b can be interchanged again. One channel can also be zeroed out in order to process
real valued signals the rest of the chain. The cordic uses a bit width of \SI{25}{\bit} internally and is
implemented in rotation mode in order to be able to shift the spectrum of the incoming signal
digitally. This is used automatically by the host driver, if the LO is not able to tune exactly
to the desired center frequency. It can also be used for shifting undesired frequencies out of
the band of interest by applying an offset to the LO frequency and correcting it with the
cordic stage. A 4 stage CIC with configurable decimation ratio, and two half band filters, which
have a decimation ratio of 2 each, are used for down conversion. The small half band filter can
be turned off. Both half band filters are designed with the tool from Doolittle \cite{halfband}.
After down conversion there is a scaling stage and before handing off the samples to the FIFO,
they are clipped to \SI{16}{\bit}.

The design is prepared for custom DSP functionality, which can be inserted in front of the
cordic or after the whole chain.
\subsubsection{DSP TX chain}
\label{sec:dsptx}
\begin{figure}[htb]
    \centering
\resizebox{\linewidth}{!}{
\begin{tikzpicture}
    \matrix (m1) [row sep=5mm, column sep=5mm,ampersand replacement=\&]
    {
        \&
        \node[coordinate]                           (maa0) {};      \&
        \node[coordinate]                           (maa1) {};      \&
        \node[coordinate]                           (maa2) {};      \&
        \node[coordinate]                           (maa3) {};      \&
        \node[coordinate]                           (maa4) {};      \&
        \node[coordinate]                           (maa5) {};      \&
        \node[coordinate]                           (maa6) {};      \&
        \node[coordinate]                           (maa7) {};      \&
        \node[coordinate]                           (maa8) {};      \&
        \node[coordinate]                           (maa9) {};      \&
        \node                                       (maa10) {mag};  \\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (ma0) {};       \&
        \node[coordinate]                           (ma1) {};       \&
        \node[coordinate]                           (ma2) {};       \&
        \node[coordinate]                           (ma3) {};       \&
        \node[coordinate]                           (ma4) {};       \&
        \node[coordinate]                           (ma5) {};       \&
        \node                                       (ma6) {phase};  \&
        \node[coordinate]                           (ma7) {};       \&
        \node[coordinate]                           (ma8) {};       \&
        \node[coordinate]                           (ma9) {};       \&
        \node[dspmixer]                             (ma10) {};      \&
        \node                                       (ma11) {i\_dco};\\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (m00) {};       \&
        \node[coordinate]                           (m01) {};       \&
        \node[dspsquare]                            (m02) {hb};     \&
        \node[dspsquare,label=above:small]          (m03) {hb};     \&
        \node[dspsquare]                            (m04) {CIC};    \&
        \node[coordinate]                           (m05) {};       \&
        \node[dspsquare]                            (m06) {$\sum$}; \&
        \node[coordinate]                           (m07) {};       \&
        \node[dspmixer]                             (m08) {};       \&
        \node[dspnodefull]                          (m09) {};       \&
        \node[dspadder]                             (m010){};       \&
        \node[dspadder]                             (m011) {};      \&
        \node[coordinate]                           (m012) {};      \&
        \node[coordinate]                           (m013) {};      \&
        \node[coordinate]                           (m014) {};      \&
        \node[dspnodeopen,dsp/label=above]          (m015) {adc\_a};\&
        \\
        %------------------------------------------------------------
        \node[text width=4ex] {}; \&
        \node[dspnodeopen,dsp/label=left]           (m10) {sample}; \&
        \node[coordinate]                           (m11) {};       \&
        \node[coordinate]                           (m12) {};       \&
        \node[coordinate]                           (m13) {};       \&
        \node[coordinate]                           (m14) {};       \&
        \node[coordinate]                           (m15) {};       \&
        \node[dspsquare]                            (m16) {cordic}; \&
        \node[coordinate]                           (m17) {};       \&
        \node                                       (m18) {scale};  \&
        \node[coordinate]                           (m19) {};       \&
        \node[coordinate]                           (m110){};       \&
        \node[coordinate]                           (m111){};       \&
        \node[coordinate]                           (m112){};       \&
        \node[dspswitch]                            (m113){};     \&
        \node[coordinate]                           (m114){};       \\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (m20) {};       \&
        \node[coordinate]                           (m21) {};       \&
        \node[dspsquare]                            (m22) {hb};     \&
        \node[dspsquare,label=below:small]          (m23) {hb};     \&
        \node[dspsquare]                            (m24) {CIC};    \&
        \node[coordinate]                           (m25) {};       \&
        \node[coordinate]                           (m26) {};       \&
        \node[coordinate]                           (m27) {};       \&
        \node[dspmixer]                             (m28) {};       \&
        \node[coordinate]                           (m29) {};       \&
        \node[dspadder]                             (m210){};       \&
        \node[dspadder]                             (m211){};       \&
        \node[coordinate]                           (m212){};       \&
        \node[coordinate]                           (m213){};       \&
        \node[coordinate]                           (m214){};       \&
        \node[dspnodeopen,dsp/label=below]          (m215){adc\_b}; \&
        \\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (mb0) {};       \&
        \node[coordinate]                           (mb1) {};       \&
        \node[coordinate]                           (mb2) {};       \&
        \node[coordinate]                           (mb3) {};       \&
        \node[coordinate]                           (mb4) {};       \&
        \node[coordinate]                           (mb5) {};       \&
        \node[coordinate]                           (mb6) {};       \&
        \node[coordinate]                           (mb7) {};       \&
        \node[coordinate]                           (mb8) {};       \&
        \node[coordinate]                           (mb9) {};       \&
        \node[dspmixer]                             (mb10) {};      \&
        \node                                       (mb11) {q\_dco};\\
        %------------------------------------------------------------
        \&
        \node[coordinate]                           (mbb0) {};      \&
        \node[coordinate]                           (mbb1) {};      \&
        \node[coordinate]                           (mbb2) {};      \&
        \node[coordinate]                           (mbb3) {};      \&
        \node[coordinate]                           (mbb4) {};      \&
        \node[coordinate]                           (mbb5) {};      \&
        \node[coordinate]                           (mbb6) {};      \&
        \node[coordinate]                           (mbb7) {};      \&
        \node[coordinate]                           (mbb8) {};      \&
        \node[coordinate]                           (mbb9) {};      \&
        \node                                       (mbb10) {phase};\\
    };
    \draw[dspflow] (m10) -- (m11);
    \draw[dspline] (ma6) -- (m06);
    \draw[dspconn] (m06) -- (m16);
    \draw[dspline] (m01) -- node[above] {i} (m02);
    \draw[dspline] (m21) -- node[below] {q} (m22);
    \foreach \off/\i/\j in {1mm/0/a,-1mm/2/b}
    {
        \draw[dspline] (m11) -- (m\i1);
        \begin{scope}[start chain]
            \chainin (m\i2);
            \chainin (m\i3) [join=by dspconn];
            \chainin (m\i4) [join=by dspconn];
            \chainin (m\i5) [join=by dspline];
        \end{scope}
        \draw[dspline] (m\i5) -- ([yshift=\off]m15);
        \draw[dspconn] ([yshift=\off]m15) -- ([yshift=\off]m16.west);
        \draw[dspline] ([yshift=\off]m16.east) -- ([yshift=\off]m17);
        \draw[dspline] ([yshift=\off]m16.east) -- ([yshift=\off]m17) -- (m\i7);
        \draw[dspconn] (m\i7) -- (m\i8);
        \draw[dspline] (m18) -- (m\i8);
        \draw[dspline] (m09) -- (m\j9);
        \draw[dspconn] (m\j9) -- (m\j10);
        \begin{scope}[start chain]
            \chainin (m\j\j10);
            \chainin (m\j10)[join=by dspline];
            \chainin (m\i10)[join=by dspconn];
            \chainin (m\i11)[join=by dspconn];
            \chainin (m\i12)[join=by dspline];
        \end{scope}
        \draw[dspline] (m\j11) -- (m\i11);
        \draw[dspline] (m\i12) -- ([yshift=\off]m112);
        \draw[dspconn] ([yshift=\off]m112) -- ([yshift=\off]m113.west);
        \draw[dspline] ([yshift=\off]m113.east) -- ([yshift=\off]m114) -- (m\i14);
        \draw[dspflow] (m\i14) -- (m\i15);
    }
    \draw[dspline] (m08) -- (m09);
    \draw[dspconn] (m09) -- (m010);
    \draw[dspconn] (m28) -- (m210);


    \node[draw,inner xsep=5pt,inner ysep=20pt,dashed,fit=(m09) (maa10) (mbb10),label=below:{IQ balance}] {};
    \node[draw,inner xsep=5pt,inner ysep=20pt,dashed,fit=(ma11) (mb11),label=below:{DC offset}] {};
\end{tikzpicture}
}
    \caption{DSP TX chain}
    \label{fig:txpath}
\end{figure}
The TX chain (\cref{fig:txpath}) features similar stages as the RX chain, but in reversed order and
interpolators instead of decimators. In \SI{8}{\bit} line mode the samples are first shifted by \SI{8}{\bit}.
Because of this the samples input into the TX chain are always \SI{16}{\bit} per channel. 
Bit widths are \SI{18}{\bit} after the half band filters and CIC, and \SI{24}{\bit} after the cordic.
IQ balance and DC offset are automatically configured according to calibration data generated with the commands
\verb+uhd_cal_tx_iq_balance+ and \verb+uhd_cal_tx_dc_offset+\cite{usrp_cal}.

Custom DSP functionality can be injected in front of the complete TX chain or between
scaling and IQ balance.

\subsection{GNU Radio}
\label{sec:intgnu}
GNU Radio is a software which provides a framework for creating software defined radios. It consists
of signal processing modules which are written in C++, a flowgraph oriented framework which can be
used from C++ and python, and the accompanying program ``GNU Radio Companion''\cite{gnuradio_grc},
which provides a graphical user interface for easier flowgraph creation. Since GNU Radio comes
with a wide variety of signal processing modules and an easy to use graphical user interface,
even complicated old radio systems can be rebuilt without any programming knowledge \cite{isee3}.

Since GNU Radio and the USRP drivers (called uhd) are integrated into every
major linux distribution, setup is as easy as installing the packages. There are
also several linux distributions available, which come with GNU Radio and the drivers
pre installed. One additional setup step, which is necessary, to achieve good throughput,
is to profile VOLK\footnote{Vector-Optimized Library of Kernels} with the command
\verb+volk_profile+, which selects the fastest way to do vector operations for this
particular host\cite{gnuradio_volk}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\linewidth]{grc}
    \caption{GNU Radio companion RX flowgraph}
    \label{fig:grc_rx}
\end{figure}
An example flowgraph, which has been used for RX measurements, can be seen in \cref{fig:grc_rx}.
Every flowgraph has an {\ttfamily Options} block, which determines the name of the output module ({\ttfamily ID}),
which GUI to use for the application ({\ttfamily Generate Options}), and some optional runtime options.
{\ttfamily Parameter} blocks can be used for passing values from either a calling flowgraph or as has
been used in this example for passing values via command line arguments. {\ttfamily Type} specifies the
data type, {\ttfamily ID} the name of the command line argument and the name of the generated variable,
and {\ttfamily Value} an optional default. Signal processing blocks have input and/or output ports, that
need to be connected. The flowgraph \cref{fig:grc_rx} creates a gnuradio program, that samples
packets from an USRP source, drops the first \SI{10}{\kilo\samples} ({\ttfamily Skip Head}), and writes
them to the file named {\ttfamily filename} ({\ttfamily File Sink}). {\ttfamily Head} stops processing after the
specified number of samples. Although most of the parameters have numerical values, they actually
reference the parameters on top. GNU Radio Companion displays the default values of the parameters,
if there are any given. Compiling this flowgraph creates a python script called {\ttfamily rx.py} which
can now directly used, or adapted to requirements, that can not be met by GNU Radio Companion (e.g.
conditionally instantiating flowgraph modules).

\begin{figure}[htbp]
    \centering
    \begin{lstlisting}[basicstyle=\tiny,caption={Generated RX flowgraph module with modifications ({\ttfamily rx\_final.py)}},label=lst:rxfinal.py]
#!/usr/bin/env python
##################################################
# Gnuradio Python Flow Graph
# Title: Receiver for Measurements
# Author: Gernot Vormayr
# Generated: Wed Dec  3 10:00:57 2014
##################################################

from gnuradio import blocks
from gnuradio import eng_notation
from gnuradio import gr
from gnuradio import uhd
from gnuradio.eng_option import eng_option
from gnuradio.filter import firdes
from optparse import OptionParser
import time

class rx(gr.top_block): (*\label{line:classdef}*)
def __init__(self, freq=2.4e9, gain=0, filename="", samples=1000000, lo_off=0, dc=0, samp_rate=50e6, wire=8): (*\label{line:init}*)
        gr.top_block.__init__(self, "Receiver for Measurements")
        if wire == 8: (*\label{line:w81}*)
            otw_format = "sc8"
            bs = gr.sizeof_char*2
        elif wire == 16:
            otw_format = "sc16"
            bs = gr.sizeof_short*2

        ################################################## (*\label{line:blockinst}*)
        # Blocks
        ##################################################
        self.uhd_usrp_source_0 = uhd.usrp_source(
        	device_addr="addr=192.168.10.2",
        	stream_args=uhd.stream_args(
        		cpu_format="sc16",
        		otw_format=otw_format,
        		channels=range(1),
        	),
        )
        self.uhd_usrp_source_0.set_clock_source("external", 0)
        self.uhd_usrp_source_0.set_samp_rate(samp_rate)
        self.uhd_usrp_source_0.set_center_freq(uhd.tune_request(freq, lo_off), 0)
        self.uhd_usrp_source_0.set_gain(gain, 0)
        if dc == 0:
            self.uhd_usrp_source_0.set_auto_dc_offset(False) (*\label{line:dcoff1}*)
	    self.uhd_usrp_source_0.set_dc_offset(0)          (*\label{line:dcoff2}*)
        self.blocks_skiphead_0 = blocks.skiphead(bs, int(samp_rate))
        if wire == 8: (*\label{line:w82}*)
        self.blocks_short_to_char_0 = blocks.short_to_char(2) (*\label{line:short}*)
        self.blocks_head_0 = blocks.head(bs, samples)
        self.blocks_file_sink_0 = blocks.file_sink(bs, filename, False)
        self.blocks_file_sink_0.set_unbuffered(False)

        ################################################## (*\label{line:conninst}*)
        # Connections
        ##################################################
        if wire == 8: (*\label{line:w83}*)
            self.connect((self.uhd_usrp_source_0, 0), (self.blocks_short_to_char_0, 0))
            self.connect((self.blocks_short_to_char_0, 0), (self.blocks_skiphead_0, 0))
        elif wire == 16:
            self.connect((self.uhd_usrp_source_0, 0), (self.blocks_skiphead_0, 0))
        self.connect((self.blocks_skiphead_0, 0), (self.blocks_head_0, 0))
        self.connect((self.blocks_head_0, 0), (self.blocks_file_sink_0, 0))
(*\label{line:setters}*)
if __name__ == '__main__': (*\label{line:main}*)
    parser = OptionParser(option_class=eng_option, usage="%prog: [options]")
    parser.add_option("", "--freq", dest="freq", type="eng_float", default=eng_notation.num_to_str(2.4e9), help="Set freq [default=%default]")
    parser.add_option("", "--gain", dest="gain", type="eng_float", default=eng_notation.num_to_str(0), help="Set gain [default=%default]")
    parser.add_option("", "--filename", dest="filename", type="string", default="", help="Set filename [default=%default]")
    parser.add_option("", "--samples", dest="samples", type="intx", default=1000000, help="Set samples [default=%default]")
    parser.add_option("", "--lo-off", dest="lo_off", type="eng_float", default=eng_notation.num_to_str(0), help="Set lo_off [default=%default]")
    parser.add_option("", "--dc", dest="dc", type="intx", default=0, help="Set dc [default=%default]")
    parser.add_option("", "--samp-rate", dest="samp_rate", type="eng_float", default=eng_notation.num_to_str(50e6), help="Set samp_rate [default=%default]")
    parser.add_option("", "--wire", dest="wire", type="intx", default=8, help="Set wire [default=%default]")
    (options, args) = parser.parse_args()
    if gr.enable_realtime_scheduling() != gr.RT_OK:
        print "Error: failed to enable realtime scheduling."
    tb = rx(freq=options.freq, gain=options.gain, filename=options.filename, samples=options.samples, lo_off=options.lo_off, dc=options.dc, samp_rate=options.samp_rate, wire=options.wire)
    tb.start() (*\label{line:start}*)
    tb.wait() (*\label{line:wait}*)
    \end{lstlisting}
\end{figure}
The generated script follows a predefined structure. An example of a modified python
file can be seen in \cref{lst:rxfinal.py}. Generated versions contain a class
(\cref{line:classdef}) which represents the flowgraph. In the
\lstinline{__init__} function (\cref{line:init}) the whole flowgraph,
starting with the blocks (\cref{line:blockinst}) followed by the connections
(\cref{line:conninst}), is instantiated. Normally GNU Radio Companion would insert
getters and setters for all variables in \cref{line:setters}, but those have been
remove from the script, because those are only needed for graphical user interfaces,
to synchronize the displayed values with the used ones. The last block in the file
represents the main function (\cref{line:main}), which gets executed, when the script
is called directly, instead of importing it into a larger project. This block parses
the arguments handed over to the script, does necessary setup, instantiates
the defined class, starts the processing (\cref{line:start}) asynchronously, and waits for completion
(\cref{line:wait}). \lstinline{tb.stop()} could be used between those two functions to
stop processing early. Additional information on the particular modifications are in
\cref{sec:measgnu}.
%======================================================================
\section{Measurement Setup}
All the measurements and data processing have been done utilizing the following tools:
\subsection{Mathworks Matlab}
Matlab has been used to automate the measurements, process the raw data, and for
initial visualization of the data. USRP control and data acquisition was planned to
be done from matlab directly with the hardware drivers supplied by Mathworks \cite{matlab_usrp},
which proved futile, because the matlab drivers for
USRP only provide very basic functionality. E.g. support for setting the clock to
external is missing. Another problem has been, that matlab was too slow for processing
data at a sample rate of \SI{50}{\mega\samples\per\second}. This led to the approach of
using GNU Radio for communicating with the USRP. Two GNU Radio flowgraphs were
developed and modified, that write the samples to a file in memory or read them
(see \cref{sec:measgnu}). Acompanying Matlab functions were developed that convert
between the binary data and complex Matlab vectors.

Because of no available VISA stack, automation of the meters was done via
SCPI\footnote{Standard Commands for Programmable Instruments} over Ethernet and VXI-11.
To be able to use VXI-11 without a VISA stack a python library \cite{yamamoto_vxi-11} was
utilized.
\subsection{GNU Radio}
\label{sec:measgnu}
As meantioned in \cref{sec:intgnu} two communication scripts have been developed with GNU
Radio to write USRP samples to a file, and read samples from a file and send them to the USRP.
Tests showed that right after starting the flowgraph there are phase errors despite a
locked LO, which is checked by the USRP driver. Because of this the flowgraph in \cref{fig:grc_rx}
uses a {\ttfamily Skip Head} module, which skips enough samples.

Because the USRP GNU Radio Companion module has no GUI parameter to turn off DC offset
compensation, the output script was modified by hand. Despite lacking some possibilities
in the interface, it is however possible to do everything from within python.
\Cref{line:dcoff1} and \cref{line:dcoff2} in \cref{lst:rxfinal.py} turn off DC offset
compensation by disabling the accumulator and setting the accumulator value to zero 
(see \cref{sec:dsprx}).

Several other additions (\Cref{line:w81,line:w82,line:w83} in \cref{lst:rxfinal.py})
make the flowgraph more dynamic, to support \SI{8}{\bit} and \SI{16}{\bit} mode with
the same python script. In \SI{8}{\bit} mode an additional block in \cref{line:short}
is added to the flowgraph, which converts the short integers from the USRP source to
characters. This is necessary because the USRP block has a very limited choice of
output data formats.

The transmit script is very similar to the receive script. Only differences are,
that the read file data is repeated in a loop, and an additional functionality
allows for endless streaming, which is cancelled on receiveing a line feed on
standard input.
\subsection{Meters and Measurment Setup}
A Rhode \& Schwarz SMBV 100a, and a Rhode \& Schwarz SMIQ06B were used to generate
signals for RX measurements and as clock reference. Since the SMIQ06B posesses no
Ethernet connectivity, an Agilent E85810 GPIB Etheret bridge provided the necessary
conversion. Power measurements were taken with an Agilent N1914A Power meter and an
Agilent E9301A Power Sensor. Network parameters and power measurements of specific
spectrum ranges were done with a Rhode \& Schwarz ZVL. The following section describe
each setup in more detail.
\subsubsection{RF Frequency Response}
\begin{figure}[htb]
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}
            \matrix (m) [matrix of nodes,
                row sep=1cm,
                column sep=1cm,
                ampersand replacement=\&,
                nodes={draw,
                    line width=1pt,
                    anchor=center, 
                    text centered,
                    rounded corners,
                    minimum width=1.5cm,
                    minimum height=8mm
                }]
            {
                USRP \& \SI{6}{\deci\bel} attn \& SMBV \\
                \begin{tabular}{l}PC \\ Matlab\end{tabular} \& \\
            };
            \draw[dashed] (m-2-1) -- node [pos=0.25,auto] {eth0} (m-1-1);
            \draw[rounded corners,dashed] (m-2-1)  -| node [pos=0.05,auto] {eth1} (m-1-3);
            \draw[thick] (m-1-1) -- node [pos=0.3,auto] {RX} (m-1-2) -- (m-1-3);
        \end{tikzpicture}
        }
        \caption{RX}
    \end{subfigure}
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}
            \matrix (m) [matrix of nodes,
                row sep=1cm,
                column sep=1cm,
                ampersand replacement=\&,
                nodes={draw,
                    line width=1pt,
                    anchor=center, 
                    text centered,
                    rounded corners,
                    minimum width=1.5cm,
                    minimum height=8mm
                }]
            {
                USRP \& \SI{16}{\deci\bel} attn \& Power Meter \\
                \begin{tabular}{l}PC \\ Matlab\end{tabular} \& \\
            };
            \draw[dashed] (m-2-1) -- node [pos=0.25,auto] {eth0} (m-1-1);
            \draw[rounded corners,dashed] (m-2-1)  -| node [pos=0.05,auto] {eth1} (m-1-3);
            \draw[thick] (m-1-1) -- node [pos=0.3,auto] {TX} (m-1-2) -- (m-1-3);
        \end{tikzpicture}
        }
        \caption{TX}
    \end{subfigure}
    \caption{RF frequency response measurement setup}
    \label{fig:rfsetup}
\end{figure}
A Rhode \& Schwarz SMBV 100a was used to generate signals for RX measurements and
as a clock reference. Output
\subsubsection{IF Frequency Response}
\subsubsection{Intermodulation properties}
\section{Measurement Results}
\subsection{RF Frequency Response}
\subsubsection{RX}
\begin{itemize}
    \item Setup (smbv -> cable -> usrp)
    \item 1MHz offset (dc!)
\end{itemize}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        legend style={font=\footnotesize},
        xlabel={gain},
        ylabel={power},
        x unit={\deci\bel},
        y unit={\deci\belm},
        minor tick num = 1
        ]
        \addplot[mark = +] table {data/rf/rx/8/dbm_400};
        \addplot[mark = x] table {data/rf/rx/8/dbm_2400};
        \addplot[mark = asterisk] table {data/rf/rx/8/dbm_4400};
        \legend{\SI{400}{MHz},\SI{2.4}{GHz},\SI{4.4}{GHz}}
    \end{axis}
\end{tikzpicture}
    \caption{Input power needed for full scale}
    \label{fig:inputfscrf}
\end{figure}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        legend style={font=\footnotesize},
        ylabel={gain},
        xlabel={frequency},
        y unit={\deci\bel},
        x unit={\hertz},
        change x base,
        x SI prefix=giga,
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1
        ]
        \addplot[mark = +] table {data/rf/rx/8/f_0};
        \addplot[mark = x] table {data/rf/rx/8/f_15};
        \addplot[mark = asterisk] table {data/rf/rx/8/f_30};
        \legend{\SI{0}{dBm},\SI{15}{dBm},\SI{30}{dBm}}
    \end{axis}
\end{tikzpicture}
    \caption{Gain needed for fullscale}
    \label{fig:gainfscrf}
\end{figure}
\begin{itemize}
    \item describe the drop from 400 -> 4.4Ghz (caused by amps)
    \item 31.5dB max
\end{itemize}
\subsubsection{TX}
\begin{itemize}
    \item usrp -> 16dB att (10dB + 6 dB) -> pwr meter
    \item measured cable
\end{itemize}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        legend style={font=\footnotesize},
        ylabel={power},
        xlabel={frequency},
        y unit={\deci\belm},
        x unit={\hertz},
        change x base,
        x SI prefix=giga,
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1,
        ymin = -25
        ]
        \addplot[mark = +] table {data/rf/tx/0.8/0.0};
        \addplot[mark = x] table {data/rf/tx/0.8/10.0};
        \addplot[mark = asterisk] table {data/rf/tx/0.8/20.0};
        \addplot[mark = triangle] table {data/rf/tx/0.8/30.0};
        \addplot[mark = 10-pointed star] table {data/rf/tx/0.8/31.5};
        \legend{\SI{0}{dB},\SI{10}{dB},\SI{20}{dB},\SI{30}{dB},\SI{31.5}{dB}}
    \end{axis}
\end{tikzpicture}
    \caption{Output power, 0.8fsc}
    \label{fig:outputrf08}
\end{figure}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        legend style={font=\footnotesize},
        ylabel={power},
        xlabel={frequency},
        y unit={\deci\belm},
        x unit={\hertz},
        change x base,
        x SI prefix=giga,
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1,
        ymin = -25
        ]
        \addplot[mark = +] table {data/rf/tx/1.0/0.0};
        \addplot[mark = x] table {data/rf/tx/1.0/10.0};
        \addplot[mark = asterisk] table {data/rf/tx/1.0/20.0};
        \addplot[mark = triangle] table {data/rf/tx/1.0/30.0};
        \addplot[mark = 10-pointed star] table {data/rf/tx/1.0/31.5};
        \legend{\SI{0}{dB},\SI{10}{dB},\SI{20}{dB},\SI{30}{dB},\SI{31.5}{dB}}
    \end{axis}
\end{tikzpicture}
    \caption{Output power, 1fsc}
    \label{fig:outputrf1}
\end{figure}
\begin{itemize}
    \item describe where stuff is comming from
\end{itemize}
\subsection{IF Frequency Response}
\subsubsection{TX}
\label{sec:rftx}
\begin{itemize}
    \item 8Bit vs 16 Bit
\end{itemize}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        ylabel={if frequency},
        xlabel={rf frequency},
        zlabel={output power},
        xlabel style={sloped},
        ylabel style={sloped},
        x unit={\hertz},
        change x base,
        x SI prefix=giga,
        y unit={\hertz},
        change y base,
        y SI prefix=mega,
        z unit={\deci\belm},
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1,
        ]
        \addplot3[surf,mesh/cols=41] table {data/if/tx/mesh16_15.0};
    \end{axis}
\end{tikzpicture}
    \caption{RF/IF TX, 16 Bit, \SI{15.0}{\deci\bel} gain}
    \label{fig:rfiftx16}
\end{figure}

\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        xlabel={if frequency},
        ylabel={output power},
        x unit={\hertz},
        change x base,
        x SI prefix=mega,
        y unit={\deci\belm},
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1,
        ]
        \addplot[mark = +] table {data/if/tx/16_2000_15.0};
        \addplot[mark = star] table {data/if/tx/8_2000_15.0};
        \node (rechtsoben) at (axis description cs:1,1) {};
        \legend{16 Bit,8 Bit}
    \end{axis}
    \begin{axis}[
        at={(rechtsoben)},
        anchor=north east,
        scale only axis,
        minor tick num = 1,
        axis background/.style={fill=white},
        tick label style={font=\tiny},
        xmin = -3e6,
        xmax = 3e6,
        ymax = -8.6,
        ymin = -9.8,
        scaled x ticks={base 10:-6},
        xtick scale label code/.code={},
        width = 2cm
        ]
        \addplot[mark = +] table {data/if/tx/16_2000_15.0};
        \addplot[mark = star] table {data/if/tx/8_2000_15.0};
    \end{axis}
\end{tikzpicture}
    \caption{IF TX, \SI{15.0}{\deci\bel} gain, cfreq \SI{2}{\giga\hertz}}
    \label{fig:iftx}
\end{figure}

\subsection{Intermodulation Properties}
\subsubsection{RX}
\begin{itemize}
    \item SMBV - usrp did not work (seen IM caused by ADC in SMBV;)
    \item SMBV 10db dcblock - SMIQ 10db dcblock - pwr splitter - usrp
    \item probably caused by ADC
\end{itemize}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        legend style={font=\footnotesize},
        ylabel={output power},
        xlabel={input power},
        y unit={\deci\belfs},
        x unit={\deci\belm},
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1,
        ]
        \addplot[only marks, mark = +] table {data/ip3/rx/la};
        \addplot[only marks, mark = x] table {data/ip3/rx/im3};
        \addplot[only marks, mark = asterisk] table {data/ip3/rx/pim3};
        \addplot[domain = -93:-35, samples = 201,dotted] {1*x+33.0765};
        \addplot[domain = -93:-35, samples = 201,loosely dotted] {3*x+111.2541};
        \legend{$out$,$IM_3$,$IP_3$}
    \end{axis}
\end{tikzpicture}
    \caption{RX IP3}
    \label{fig:rxip3}
\end{figure}
\subsubsection{TX}
\begin{itemize}
    \item usrp - 16dB att - zvl
    \item gain stepping did not work; nor stepping zvl -> probably caused by ADC
\end{itemize}
\begin{figure}[htb]
    \centering
\begin{tikzpicture}
    \begin{axis}[
        legend pos = outer north east,
        legend style={font=\footnotesize},
        ylabel={output power},
        xlabel={input power},
        x unit={\deci\belfs},
        y unit={\deci\belm},
        width=12cm,
        height=5cm,
        scale only axis,
        minor tick num = 1,
        ]
        \addplot[only marks, mark = +] table {data/ip3/tx/la};
        \addplot[only marks, mark = x] table {data/ip3/tx/im3};
        \addplot[only marks, mark = asterisk] table {data/ip3/tx/pim3};
        \addplot[domain = -27:17, samples = 201,dotted] {1*x-4.2330};
        \addplot[domain = -27:17, samples = 201,loosely dotted] {3*x-33.6197};
        \legend{$out$,$IM_3$,$IP_3$}
    \end{axis}
\end{tikzpicture}
    \caption{TX IP3}
    \label{fig:txip3}
\end{figure}
\listoffigures
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,literature}

\end{document}
